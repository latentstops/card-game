<!DOCTYPE html>
<html lang="en">
<head>
    <title>undefined</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #fff;
            color: #fff;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }
    </style>
</head>
<body>

<script type="module">

    import * as THREE from '/three.module.js';

    THREE.Cache.enabled = true;

    let container, permalink, hex;

    let camera, cameraTarget, scene, renderer;

    let group, textMesh1, textMesh2, textGeo, materials;

    let firstLetter = true;

    let text = "undefined",

        bevelEnabled = true,

        font = undefined;

    const height = 5,
        size = 30,
        hover = 55,

        curveSegments = 5,

        bevelThickness = 2,
        bevelSize = 1.5;

    const mirror = true;

    let targetRotation = 0;
    let targetRotationOnPointerDown = 0;

    let pointerX = 0;
    let pointerXOnPointerDown = 0;

    let windowHalfX = window.innerWidth / 2;

    let fontIndex = 1;

    init();
    animate();

    function decimalToHex( d ) {

        let hex = Number( d ).toString( 16 );
        hex = "000000".substr( 0, 6 - hex.length ) + hex;
        return hex.toUpperCase();

    }

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        permalink = document.getElementById( "permalink" );

        // CAMERA

        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
        camera.position.set( 0, 400, 700 );

        cameraTarget = new THREE.Vector3( 0, 150, 0 );

        // SCENE

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xffffff );
        scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

        // LIGHTS

        const dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
        dirLight.position.set( 0, 0, 1 ).normalize();
        scene.add( dirLight );

        const pointLight = new THREE.PointLight( 0xffffff, 1.5 );
        pointLight.position.set( 0, 100, 90 );
        scene.add( pointLight );

        // Get text from hash

        const hash = document.location.hash.substr( 1 );

        if ( hash.length !== 0 ) {

            const colorhash = hash.substring( 0, 6 );
            const bevelhash = hash.substring( 8, 9 );
            const texthash = hash.substring( 10 );

            hex = colorhash;
            pointLight.color.setHex( parseInt( colorhash, 16 ) );

            bevelEnabled = parseInt( bevelhash );

            text = decodeURI( texthash );

        } else {

            pointLight.color.setHSL( Math.random(), 1, 0.5 );
            hex = decimalToHex( pointLight.color.getHex() );

        }

        materials = [
            new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
            new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
        ];

        group = new THREE.Group();
        group.position.y = 150;

        scene.add( group );

        loadFont();

        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry( 1000000, 1000000 ),
            new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.5, transparent: true } )
        );
        plane.position.y = 150;
        plane.rotation.x = - Math.PI / 3;
        scene.add( plane );

        // RENDERER

        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        // renderer.setClearColor()
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        // EVENTS

        container.style.touchAction = 'none';
        container.addEventListener( 'pointerdown', onPointerDown );


        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function loadFont() {

        const loader = new THREE.FontLoader();
        loader.load( '/optimer_bold.typeface.json', function ( response ) {

            font = response;

            refreshText();

        } );

    }

    function createText() {

        textGeo = new THREE.TextGeometry( text, {

            font: font,

            size: size,
            height: height,
            curveSegments: curveSegments,

            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: bevelEnabled

        } );

        textGeo.computeBoundingBox();

        const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

        textMesh1 = new THREE.Mesh( textGeo, materials );

        textMesh1.position.x = centerOffset;
        textMesh1.position.y = hover;
        textMesh1.position.z = 0;

        textMesh1.rotation.x = 0;
        textMesh1.rotation.y = Math.PI * 2;

        group.add( textMesh1 );

        if ( mirror ) {

            textMesh2 = new THREE.Mesh( textGeo, materials );

            textMesh2.position.x = centerOffset;
            textMesh2.position.y = - hover;
            textMesh2.position.z = height;

            textMesh2.rotation.x = Math.PI;
            textMesh2.rotation.y = Math.PI * 2;

            group.add( textMesh2 );

        }

    }

    function refreshText() {

        group.remove( textMesh1 );
        if ( mirror ) group.remove( textMesh2 );

        if ( ! text ) return;

        createText();

    }

    function onPointerDown( event ) {

        if ( event.isPrimary === false ) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener( 'pointermove', onPointerMove );
        document.addEventListener( 'pointerup', onPointerUp );

    }

    function onPointerMove( event ) {

        if ( event.isPrimary === false ) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;
        if( targetRotation <= -15 || targetRotation >= 15 ) {
            targetRotation = 0;
            location.href = '/black-jack';
        }
    }

    function onPointerUp() {

        if ( event.isPrimary === false ) return;

        document.removeEventListener( 'pointermove', onPointerMove );
        document.removeEventListener( 'pointerup', onPointerUp );

    }

    function animate() {

        requestAnimationFrame( animate );

        render();
    }

    function render() {

        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;

        camera.lookAt( cameraTarget );

        renderer.clear();
        renderer.render( scene, camera );

    }

</script>

</body>
</html>
